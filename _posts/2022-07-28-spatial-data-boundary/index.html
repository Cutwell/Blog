<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Approximating the alpha shape of spatial data using Python and Shapely.</title>
<link rel="apple-touch-icon" sizes="180x180" href="https://cutwell.github.io/blog//apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://cutwell.github.io/blog//favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://cutwell.github.io/blog//favicon-16x16.png">
<link rel="manifest" href="https://cutwell.github.io/blog//site.webmanifest">
<link rel="mask-icon" href="https://cutwell.github.io/blog//safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="My personal blog, detailing projects in AI, web design, and game development.">
<link rel="alternate" type="application/rss+xml" title="Zachary's Blog" href="https://cutwell.github.io/blog//feed.xml">
<link rel="sitemap" type="application/xml" title="Sitemap" href="https://cutwell.github.io/blog//sitemap.xml">
<link rel="canonical" href="https://cutwell.github.io/blog//_posts/2022-07-28-spatial-data-boundary/">
<meta name="google-site-verification" content="">
<meta property="og:title" content="Approximating the alpha shape of spatial data using Python and Shapely.">
<meta property="og:url" content="https://cutwell.github.io/blog//_posts/2022-07-28-spatial-data-boundary/">
<meta property="og:type" content="article">
<meta property="og:site_name" content="Zachary's Blog">
<meta property="og:description" content="My personal blog, detailing projects in AI, web design, and game development.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Approximating the alpha shape of spatial data using Python and Shapely.">
<meta name="twitter:url" content="https://cutwell.github.io/blog//_posts/2022-07-28-spatial-data-boundary/">
<meta name="twitter:description" content="My personal blog, detailing projects in AI, web design, and game development.">
<style>body { max-width: 80ch; padding: 3em 1em; margin: auto; line-height: 1.6; font-size: 1.25em; font-family: Helvetica } .d { font-size: medium; color: grey } img { max-width: 100%; height: auto } pre { overflow: auto; }</style>
<style>table th, table td { padding: 6px 13px; border: 1px solid #d0d7de } table tr { border-top: 1px solid hsla(210, 18%, 87%, 1) } table tr:nth-child(2n) { background-color: #f6f8fa } table { border-spacing: 0; border-collapse: collapse }</style>
</head>
<body>
<a style="position:absolute;top:0;left:0;margin:1em;color:inherit;font-size:1em;" href="https://cutwell.github.io/blog/">Return Home</a><h1>Approximating the alpha shape of spatial data using Python and Shapely.</h1>
<i>Written on </i> <br><i class="d"> 6 minutes to read. </i><p><img src="/_posts/2022-07-28-spatial-data-boundary/outlined.png" alt="" width="615" height="589" loading="lazy"></p>
<p>I want to talk about a unique problem of applying genetic optimisation to unusual search spaces. For my dissertation, I’m investigating a large section of seascape, off the East coast of England, to identify optimal sites for offshore wind farms (OWFs). I’ve been acquiring bathymetric data (depth of the sea at recorded points) as OWFs have a maximum depth for sinking pylons, apparently between 25-40m).</p>
<!--more--><p>The search space is restricted in shape to complement the available depth data, resulting in this unusual shape:</p>
<p><img src="/_posts/2022-07-28-spatial-data-boundary/plain.png" alt="irregularly shaped heatmap of sea floor off the east coast of England" width="615" height="589" loading="lazy">.</p>
<p>The irregular shape isn’t problematic itself - there is plenty of space within the boundary to optimise - but what is an issue is that is is difficult to restrict our optimiser to only finding solutions within the known search space.</p>
<hr>
<h2 id="genetic-optimisation">Genetic optimisation</h2>
<p>A brief explanation of genetic optimisation is that is is an algorithmic method to searching a large search space efficiently, and find multiple viable solutions that balance conflicting objectives.</p>
<p>Let’s say we have an optimisation problem: you’re at the beach, and want to find a place to sit that isn’t too close to other people (this is our first objective: maximise the distance between us and other people), however, you also want to sit down quickly - so no walking for miles to the other end of the beach (this is our second objective: minimise the distance between where we enter the beach and then sit down).</p>
<p>Our beach is the search space - we can pick any point and say how good / bad it is, with a <em>fitness</em> (score) according to how well it minimises / maximises the objectives. So a <em>solution</em> will come in the form of some coordinates, precisely locating the best spot to sit.</p>
<p>Illustrating this beach, it might look like this (red dots are people we want to avoid):</p>
<p><img src="/_posts/2022-07-28-spatial-data-boundary/beachempty.png" alt="yellow beach with red dots indicating people" width="376" height="262" loading="lazy"></p>
<p>We can apply a popular genetic algorithm “Nondominated Sorting Genetic Algorithm II” (NSGAII) to this problem. The purpose of this algorithm is to search our search space and find solutions that are equally as good as each other. In other words, one solution might be 10% quicker to reach, but only 2M from another person, whilst another might be 10% slower to reach, but 2.2M from another person. These two solutions are equally as good, since we didn’t specify one objective as having precedence over another, so we consider them “mutually nondominating”. NSGAII will attempt to create a population of solutions that are all mutually nondominating, giving maximum choice to balance our objectives as we choose.</p>
<p>Plotting theses solutions according to their objective scores can identify the pareto front - a shape defining all nondominating solutions:</p>
<p><img src="/_posts/2022-07-28-spatial-data-boundary/beachpareto.png" alt="the pareto front for the beach problem" width="382" height="262" loading="lazy"></p>
<p>We can plot these solutions on our beach, to identify the best places to sit:</p>
<p><img src="/_posts/2022-07-28-spatial-data-boundary/beachsolutions.png" alt="yellow beach with a selection of spots to sit, in green" width="376" height="262" loading="lazy"></p>
<p>Each solution (in green) is a unique balance of distance from the entrance to the beach (at coordinates (0,5)) whilst avoiding sitting near other people (in red). The best solutions draw lines straight towards the entrance, as we want to minimise this objective, and shy away from the roughly diagonal spread of people (as we’re maximising our distance).</p>
<p>These principles can be applied to lots of different problem types.</p>
<hr>
<h2 id="genetic-optimisation-for-squares">Genetic optimisation for squares</h2>
<p>Returning to our problem - imagine our search space was a triangle. A restriction of our genetic optimiser (at least using the Python package platypus-opt) is that we have to define our search space as a rectangle. Since our genetic optimisation is looking for X, Y coordinates, we can’t prevent solutions looking outside the dimensions of the triangle, since the optimiser thinks it has extra space to search.</p>
<p>However, if we can tell if our coordinates lie inside/outside the shape, we can encourage the optimiser to not stray outside the lines. If our beach was a triangle, or other weird polygon, then coordinates that aren’t valid could be given a fitness of ±infinity, strongly discouraging exploration of this space.</p>
<p>For our site selection, we need a more nuanced approach, as a solution may only slightly overlap the boundary, meaning we can instead optimise to maximise overlap of our site shape and the search space shape.</p>
<hr>
<h2 id="concave-hulls">Concave hulls</h2>
<p>Our search space has an irregular shape:</p>
<p><img src="/_posts/2022-07-28-spatial-data-boundary/plain.png" alt="" width="615" height="589" loading="lazy"></p>
<p>Defining the shape of this collection of spatial data points is expensive, as we need to process 2.2 million data points, meaning the solution must be memory efficient.</p>
<p>I initially approached this problem considering methods to remove interior data points, reducing the dataset to only exterior points, however aforementioned memory issues prevented these quick-Google-methods. Discovery that this type of shape has a proper term in geometry - alpha-shape - was the key to finding a proper solution, as Stack Overflow was much more helpful now I knew what was needed.</p>
<p>Our final boundary was an approximation of the search space shape:</p>
<p><img src="/_posts/2022-07-28-spatial-data-boundary/outlined.png" alt="" width="615" height="589" loading="lazy"></p>
<p>This boundary isn’t perfect, however it is more than accurate enough to allow us to properly determine overlap between our search space and solutions:</p>
<p><img src="/_posts/2022-07-28-spatial-data-boundary/intersection59.png" alt="" width="720" height="720" loading="lazy"></p>
<p>As above, by determing intersection % between our search space and solutions, we can encourage solutions to explore only inside the space:</p>
<p><img src="/_posts/2022-07-28-spatial-data-boundary/intersection100.png" alt="" width="720" height="720" loading="lazy"></p>
<hr>
<h2 id="final-thoughts">Final thoughts</h2>
<p>The biggest roadblock to progress in this stage was discovering the right mathematical geometry terms for what I was attempting - as ever, the problem was well established, but without the correct terminology searching didn’t get me anywhere fast.</p>
<p>My next goal is to fine tune the optimisation - possibly to force solutions to have ~99% intersection with the search space, as my current method results in some solutions with less intersection being judged “good enough”, which isn’t valid.</p>
<br><hr>
<ul>
<li>GitHub: <a href="https://github.com/Cutwell">https://github.com/Cutwell</a>
</li>
<li>LinkedIn: <a href="https://www.linkedin.com/in/zacharysmith5/">https://www.linkedin.com/in/zacharysmith5/</a>
</li>
</ul>
<i id="lt" class="d"></i><br> <i id="ps" class="d"></i> <script> document.getElementById("ps").innerHTML="Size: "+document.documentElement.outerHTML.length+" bytes"; window.onload=function(){document.getElementById("lt").innerHTML="Load time: "+(window.performance.timing.domContentLoadedEventEnd-window.performance.timing.navigationStart)+"ms"}; </script>
</body>
</html>
